/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  SignedAuthorization,
  SignedAuthorization$inboundSchema,
  SignedAuthorization$Outbound,
  SignedAuthorization$outboundSchema,
} from "./signedauthorization.js";

export const AaveLoopRequestChain = {
  Arbitrum: "arbitrum",
  Base: "base",
  Ethereum: "ethereum",
} as const;
export type AaveLoopRequestChain = ClosedEnum<typeof AaveLoopRequestChain>;

/**
 * Amount of collateral token to supply to Aave
 */
export type InitialCollateralAmount = number | string;

/**
 * Leverage multiplier. Total loop collateral will be calculated as `multiplier` x `initial_collateral_amount`
 */
export type Multiplier = number | string;

/**
 * Maximum allowed slippage for token swaps in percentage
 */
export type MaxSlippagePercent = number | string;

/**
 * Loan To Value percentage of the loop
 */
export type LoanToValue = number | string;

/**
 * Request model for executing an Aave loop strategy.
 */
export type AaveLoopRequest = {
  chain: AaveLoopRequestChain;
  /**
   * The address of the transaction sender.
   */
  sender: string;
  /**
   * Determines whether to estimate gas costs for transactions, also verifying that the transaction can be successfully executed.
   */
  estimateGas?: boolean | undefined;
  /**
   * EIP-7702 authorization. Required when `is_account_abstraction` is False.
   */
  signedAuthorization?: SignedAuthorization | null | undefined;
  /**
   * Symbol or address of token to supply to Aave..
   */
  collateralToken: string;
  /**
   * Symbol or address of token to borrow from Aave..
   */
  borrowToken: string;
  /**
   * Amount of collateral token to supply to Aave
   */
  initialCollateralAmount: number | string;
  /**
   * Leverage multiplier. Total loop collateral will be calculated as `multiplier` x `initial_collateral_amount`
   */
  multiplier: number | string;
  /**
   * Maximum allowed slippage for token swaps in percentage
   */
  maxSlippagePercent: number | string;
  /**
   * Loan To Value percentage of the loop
   */
  loanToValue: number | string;
  /**
   * Whether to use account abstraction for the transaction.
   */
  isAccountAbstraction?: boolean | undefined;
};

/** @internal */
export const AaveLoopRequestChain$inboundSchema: z.ZodNativeEnum<
  typeof AaveLoopRequestChain
> = z.nativeEnum(AaveLoopRequestChain);

/** @internal */
export const AaveLoopRequestChain$outboundSchema: z.ZodNativeEnum<
  typeof AaveLoopRequestChain
> = AaveLoopRequestChain$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AaveLoopRequestChain$ {
  /** @deprecated use `AaveLoopRequestChain$inboundSchema` instead. */
  export const inboundSchema = AaveLoopRequestChain$inboundSchema;
  /** @deprecated use `AaveLoopRequestChain$outboundSchema` instead. */
  export const outboundSchema = AaveLoopRequestChain$outboundSchema;
}

/** @internal */
export const InitialCollateralAmount$inboundSchema: z.ZodType<
  InitialCollateralAmount,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string()]);

/** @internal */
export type InitialCollateralAmount$Outbound = number | string;

/** @internal */
export const InitialCollateralAmount$outboundSchema: z.ZodType<
  InitialCollateralAmount$Outbound,
  z.ZodTypeDef,
  InitialCollateralAmount
> = z.union([z.number(), z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InitialCollateralAmount$ {
  /** @deprecated use `InitialCollateralAmount$inboundSchema` instead. */
  export const inboundSchema = InitialCollateralAmount$inboundSchema;
  /** @deprecated use `InitialCollateralAmount$outboundSchema` instead. */
  export const outboundSchema = InitialCollateralAmount$outboundSchema;
  /** @deprecated use `InitialCollateralAmount$Outbound` instead. */
  export type Outbound = InitialCollateralAmount$Outbound;
}

export function initialCollateralAmountToJSON(
  initialCollateralAmount: InitialCollateralAmount,
): string {
  return JSON.stringify(
    InitialCollateralAmount$outboundSchema.parse(initialCollateralAmount),
  );
}

export function initialCollateralAmountFromJSON(
  jsonString: string,
): SafeParseResult<InitialCollateralAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InitialCollateralAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InitialCollateralAmount' from JSON`,
  );
}

/** @internal */
export const Multiplier$inboundSchema: z.ZodType<
  Multiplier,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string()]);

/** @internal */
export type Multiplier$Outbound = number | string;

/** @internal */
export const Multiplier$outboundSchema: z.ZodType<
  Multiplier$Outbound,
  z.ZodTypeDef,
  Multiplier
> = z.union([z.number(), z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Multiplier$ {
  /** @deprecated use `Multiplier$inboundSchema` instead. */
  export const inboundSchema = Multiplier$inboundSchema;
  /** @deprecated use `Multiplier$outboundSchema` instead. */
  export const outboundSchema = Multiplier$outboundSchema;
  /** @deprecated use `Multiplier$Outbound` instead. */
  export type Outbound = Multiplier$Outbound;
}

export function multiplierToJSON(multiplier: Multiplier): string {
  return JSON.stringify(Multiplier$outboundSchema.parse(multiplier));
}

export function multiplierFromJSON(
  jsonString: string,
): SafeParseResult<Multiplier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Multiplier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Multiplier' from JSON`,
  );
}

/** @internal */
export const MaxSlippagePercent$inboundSchema: z.ZodType<
  MaxSlippagePercent,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string()]);

/** @internal */
export type MaxSlippagePercent$Outbound = number | string;

/** @internal */
export const MaxSlippagePercent$outboundSchema: z.ZodType<
  MaxSlippagePercent$Outbound,
  z.ZodTypeDef,
  MaxSlippagePercent
> = z.union([z.number(), z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaxSlippagePercent$ {
  /** @deprecated use `MaxSlippagePercent$inboundSchema` instead. */
  export const inboundSchema = MaxSlippagePercent$inboundSchema;
  /** @deprecated use `MaxSlippagePercent$outboundSchema` instead. */
  export const outboundSchema = MaxSlippagePercent$outboundSchema;
  /** @deprecated use `MaxSlippagePercent$Outbound` instead. */
  export type Outbound = MaxSlippagePercent$Outbound;
}

export function maxSlippagePercentToJSON(
  maxSlippagePercent: MaxSlippagePercent,
): string {
  return JSON.stringify(
    MaxSlippagePercent$outboundSchema.parse(maxSlippagePercent),
  );
}

export function maxSlippagePercentFromJSON(
  jsonString: string,
): SafeParseResult<MaxSlippagePercent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MaxSlippagePercent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MaxSlippagePercent' from JSON`,
  );
}

/** @internal */
export const LoanToValue$inboundSchema: z.ZodType<
  LoanToValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.string()]);

/** @internal */
export type LoanToValue$Outbound = number | string;

/** @internal */
export const LoanToValue$outboundSchema: z.ZodType<
  LoanToValue$Outbound,
  z.ZodTypeDef,
  LoanToValue
> = z.union([z.number(), z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LoanToValue$ {
  /** @deprecated use `LoanToValue$inboundSchema` instead. */
  export const inboundSchema = LoanToValue$inboundSchema;
  /** @deprecated use `LoanToValue$outboundSchema` instead. */
  export const outboundSchema = LoanToValue$outboundSchema;
  /** @deprecated use `LoanToValue$Outbound` instead. */
  export type Outbound = LoanToValue$Outbound;
}

export function loanToValueToJSON(loanToValue: LoanToValue): string {
  return JSON.stringify(LoanToValue$outboundSchema.parse(loanToValue));
}

export function loanToValueFromJSON(
  jsonString: string,
): SafeParseResult<LoanToValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LoanToValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LoanToValue' from JSON`,
  );
}

/** @internal */
export const AaveLoopRequest$inboundSchema: z.ZodType<
  AaveLoopRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  chain: AaveLoopRequestChain$inboundSchema,
  sender: z.string(),
  estimate_gas: z.boolean().default(true),
  signed_authorization: z.nullable(SignedAuthorization$inboundSchema)
    .optional(),
  collateral_token: z.string(),
  borrow_token: z.string(),
  initial_collateral_amount: z.union([z.number(), z.string()]),
  multiplier: z.union([z.number(), z.string()]),
  max_slippage_percent: z.union([z.number(), z.string()]),
  loan_to_value: z.union([z.number(), z.string()]),
  is_account_abstraction: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "estimate_gas": "estimateGas",
    "signed_authorization": "signedAuthorization",
    "collateral_token": "collateralToken",
    "borrow_token": "borrowToken",
    "initial_collateral_amount": "initialCollateralAmount",
    "max_slippage_percent": "maxSlippagePercent",
    "loan_to_value": "loanToValue",
    "is_account_abstraction": "isAccountAbstraction",
  });
});

/** @internal */
export type AaveLoopRequest$Outbound = {
  chain: string;
  sender: string;
  estimate_gas: boolean;
  signed_authorization?: SignedAuthorization$Outbound | null | undefined;
  collateral_token: string;
  borrow_token: string;
  initial_collateral_amount: number | string;
  multiplier: number | string;
  max_slippage_percent: number | string;
  loan_to_value: number | string;
  is_account_abstraction: boolean;
};

/** @internal */
export const AaveLoopRequest$outboundSchema: z.ZodType<
  AaveLoopRequest$Outbound,
  z.ZodTypeDef,
  AaveLoopRequest
> = z.object({
  chain: AaveLoopRequestChain$outboundSchema,
  sender: z.string(),
  estimateGas: z.boolean().default(true),
  signedAuthorization: z.nullable(SignedAuthorization$outboundSchema)
    .optional(),
  collateralToken: z.string(),
  borrowToken: z.string(),
  initialCollateralAmount: z.union([z.number(), z.string()]),
  multiplier: z.union([z.number(), z.string()]),
  maxSlippagePercent: z.union([z.number(), z.string()]),
  loanToValue: z.union([z.number(), z.string()]),
  isAccountAbstraction: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    estimateGas: "estimate_gas",
    signedAuthorization: "signed_authorization",
    collateralToken: "collateral_token",
    borrowToken: "borrow_token",
    initialCollateralAmount: "initial_collateral_amount",
    maxSlippagePercent: "max_slippage_percent",
    loanToValue: "loan_to_value",
    isAccountAbstraction: "is_account_abstraction",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AaveLoopRequest$ {
  /** @deprecated use `AaveLoopRequest$inboundSchema` instead. */
  export const inboundSchema = AaveLoopRequest$inboundSchema;
  /** @deprecated use `AaveLoopRequest$outboundSchema` instead. */
  export const outboundSchema = AaveLoopRequest$outboundSchema;
  /** @deprecated use `AaveLoopRequest$Outbound` instead. */
  export type Outbound = AaveLoopRequest$Outbound;
}

export function aaveLoopRequestToJSON(
  aaveLoopRequest: AaveLoopRequest,
): string {
  return JSON.stringify(AaveLoopRequest$outboundSchema.parse(aaveLoopRequest));
}

export function aaveLoopRequestFromJSON(
  jsonString: string,
): SafeParseResult<AaveLoopRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AaveLoopRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AaveLoopRequest' from JSON`,
  );
}
