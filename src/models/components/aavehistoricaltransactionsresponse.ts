/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  Borrow,
  Borrow$inboundSchema,
  Borrow$Outbound,
  Borrow$outboundSchema,
} from "./borrow.js";
import {
  LiquidationCall,
  LiquidationCall$inboundSchema,
  LiquidationCall$Outbound,
  LiquidationCall$outboundSchema,
} from "./liquidationcall.js";
import {
  RedeemUnderlying,
  RedeemUnderlying$inboundSchema,
  RedeemUnderlying$Outbound,
  RedeemUnderlying$outboundSchema,
} from "./redeemunderlying.js";
import {
  Repay,
  Repay$inboundSchema,
  Repay$Outbound,
  Repay$outboundSchema,
} from "./repay.js";
import {
  Supply,
  Supply$inboundSchema,
  Supply$Outbound,
  Supply$outboundSchema,
} from "./supply.js";
import {
  SwapBorrowRate,
  SwapBorrowRate$inboundSchema,
  SwapBorrowRate$Outbound,
  SwapBorrowRate$outboundSchema,
} from "./swapborrowrate.js";
import {
  UsageAsCollateral,
  UsageAsCollateral$inboundSchema,
  UsageAsCollateral$Outbound,
  UsageAsCollateral$outboundSchema,
} from "./usageascollateral.js";

export type AaveHistoricalTransactionsResponseTransaction =
  | (LiquidationCall & { action: "LiquidationCall" })
  | (SwapBorrowRate & { action: "SwapBorrowRate" })
  | (Borrow & { action: "Borrow" })
  | (RedeemUnderlying & { action: "RedeemUnderlying" })
  | (Repay & { action: "Repay" })
  | (Supply & { action: "Supply" })
  | (UsageAsCollateral & { action: "UsageAsCollateral" });

/**
 * Response model for getting Aave historical transactions.
 */
export type AaveHistoricalTransactionsResponse = {
  /**
   * Specifies how many transactions to skip before returning results, letting you choose the starting point for the data you want to receive.
   */
  offset: number;
  /**
   * Sets the maximum number of transactions to include in the response, helping control the size of the returned dataset.
   */
  limit: number;
  transactions: Array<
    | (LiquidationCall & { action: "LiquidationCall" })
    | (SwapBorrowRate & { action: "SwapBorrowRate" })
    | (Borrow & { action: "Borrow" })
    | (RedeemUnderlying & { action: "RedeemUnderlying" })
    | (Repay & { action: "Repay" })
    | (Supply & { action: "Supply" })
    | (UsageAsCollateral & { action: "UsageAsCollateral" })
  >;
};

/** @internal */
export const AaveHistoricalTransactionsResponseTransaction$inboundSchema:
  z.ZodType<
    AaveHistoricalTransactionsResponseTransaction,
    z.ZodTypeDef,
    unknown
  > = z.union([
    LiquidationCall$inboundSchema.and(
      z.object({ action: z.literal("LiquidationCall") }).transform((v) => ({
        action: v.action,
      })),
    ),
    SwapBorrowRate$inboundSchema.and(
      z.object({ action: z.literal("SwapBorrowRate") }).transform((v) => ({
        action: v.action,
      })),
    ),
    Borrow$inboundSchema.and(
      z.object({ action: z.literal("Borrow") }).transform((v) => ({
        action: v.action,
      })),
    ),
    RedeemUnderlying$inboundSchema.and(
      z.object({ action: z.literal("RedeemUnderlying") }).transform((v) => ({
        action: v.action,
      })),
    ),
    Repay$inboundSchema.and(
      z.object({ action: z.literal("Repay") }).transform((v) => ({
        action: v.action,
      })),
    ),
    Supply$inboundSchema.and(
      z.object({ action: z.literal("Supply") }).transform((v) => ({
        action: v.action,
      })),
    ),
    UsageAsCollateral$inboundSchema.and(
      z.object({ action: z.literal("UsageAsCollateral") }).transform((v) => ({
        action: v.action,
      })),
    ),
  ]);

/** @internal */
export type AaveHistoricalTransactionsResponseTransaction$Outbound =
  | (LiquidationCall$Outbound & { action: "LiquidationCall" })
  | (SwapBorrowRate$Outbound & { action: "SwapBorrowRate" })
  | (Borrow$Outbound & { action: "Borrow" })
  | (RedeemUnderlying$Outbound & { action: "RedeemUnderlying" })
  | (Repay$Outbound & { action: "Repay" })
  | (Supply$Outbound & { action: "Supply" })
  | (UsageAsCollateral$Outbound & { action: "UsageAsCollateral" });

/** @internal */
export const AaveHistoricalTransactionsResponseTransaction$outboundSchema:
  z.ZodType<
    AaveHistoricalTransactionsResponseTransaction$Outbound,
    z.ZodTypeDef,
    AaveHistoricalTransactionsResponseTransaction
  > = z.union([
    LiquidationCall$outboundSchema.and(
      z.object({ action: z.literal("LiquidationCall") }).transform((v) => ({
        action: v.action,
      })),
    ),
    SwapBorrowRate$outboundSchema.and(
      z.object({ action: z.literal("SwapBorrowRate") }).transform((v) => ({
        action: v.action,
      })),
    ),
    Borrow$outboundSchema.and(
      z.object({ action: z.literal("Borrow") }).transform((v) => ({
        action: v.action,
      })),
    ),
    RedeemUnderlying$outboundSchema.and(
      z.object({ action: z.literal("RedeemUnderlying") }).transform((v) => ({
        action: v.action,
      })),
    ),
    Repay$outboundSchema.and(
      z.object({ action: z.literal("Repay") }).transform((v) => ({
        action: v.action,
      })),
    ),
    Supply$outboundSchema.and(
      z.object({ action: z.literal("Supply") }).transform((v) => ({
        action: v.action,
      })),
    ),
    UsageAsCollateral$outboundSchema.and(
      z.object({ action: z.literal("UsageAsCollateral") }).transform((v) => ({
        action: v.action,
      })),
    ),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AaveHistoricalTransactionsResponseTransaction$ {
  /** @deprecated use `AaveHistoricalTransactionsResponseTransaction$inboundSchema` instead. */
  export const inboundSchema =
    AaveHistoricalTransactionsResponseTransaction$inboundSchema;
  /** @deprecated use `AaveHistoricalTransactionsResponseTransaction$outboundSchema` instead. */
  export const outboundSchema =
    AaveHistoricalTransactionsResponseTransaction$outboundSchema;
  /** @deprecated use `AaveHistoricalTransactionsResponseTransaction$Outbound` instead. */
  export type Outbound = AaveHistoricalTransactionsResponseTransaction$Outbound;
}

export function aaveHistoricalTransactionsResponseTransactionToJSON(
  aaveHistoricalTransactionsResponseTransaction:
    AaveHistoricalTransactionsResponseTransaction,
): string {
  return JSON.stringify(
    AaveHistoricalTransactionsResponseTransaction$outboundSchema.parse(
      aaveHistoricalTransactionsResponseTransaction,
    ),
  );
}

export function aaveHistoricalTransactionsResponseTransactionFromJSON(
  jsonString: string,
): SafeParseResult<
  AaveHistoricalTransactionsResponseTransaction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AaveHistoricalTransactionsResponseTransaction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AaveHistoricalTransactionsResponseTransaction' from JSON`,
  );
}

/** @internal */
export const AaveHistoricalTransactionsResponse$inboundSchema: z.ZodType<
  AaveHistoricalTransactionsResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  offset: z.number().int(),
  limit: z.number().int(),
  transactions: z.array(
    z.union([
      LiquidationCall$inboundSchema.and(
        z.object({ action: z.literal("LiquidationCall") }).transform((v) => ({
          action: v.action,
        })),
      ),
      SwapBorrowRate$inboundSchema.and(
        z.object({ action: z.literal("SwapBorrowRate") }).transform((v) => ({
          action: v.action,
        })),
      ),
      Borrow$inboundSchema.and(
        z.object({ action: z.literal("Borrow") }).transform((v) => ({
          action: v.action,
        })),
      ),
      RedeemUnderlying$inboundSchema.and(
        z.object({ action: z.literal("RedeemUnderlying") }).transform((v) => ({
          action: v.action,
        })),
      ),
      Repay$inboundSchema.and(
        z.object({ action: z.literal("Repay") }).transform((v) => ({
          action: v.action,
        })),
      ),
      Supply$inboundSchema.and(
        z.object({ action: z.literal("Supply") }).transform((v) => ({
          action: v.action,
        })),
      ),
      UsageAsCollateral$inboundSchema.and(
        z.object({ action: z.literal("UsageAsCollateral") }).transform((v) => ({
          action: v.action,
        })),
      ),
    ]),
  ),
});

/** @internal */
export type AaveHistoricalTransactionsResponse$Outbound = {
  offset: number;
  limit: number;
  transactions: Array<
    | (LiquidationCall$Outbound & { action: "LiquidationCall" })
    | (SwapBorrowRate$Outbound & { action: "SwapBorrowRate" })
    | (Borrow$Outbound & { action: "Borrow" })
    | (RedeemUnderlying$Outbound & { action: "RedeemUnderlying" })
    | (Repay$Outbound & { action: "Repay" })
    | (Supply$Outbound & { action: "Supply" })
    | (UsageAsCollateral$Outbound & { action: "UsageAsCollateral" })
  >;
};

/** @internal */
export const AaveHistoricalTransactionsResponse$outboundSchema: z.ZodType<
  AaveHistoricalTransactionsResponse$Outbound,
  z.ZodTypeDef,
  AaveHistoricalTransactionsResponse
> = z.object({
  offset: z.number().int(),
  limit: z.number().int(),
  transactions: z.array(
    z.union([
      LiquidationCall$outboundSchema.and(
        z.object({ action: z.literal("LiquidationCall") }).transform((v) => ({
          action: v.action,
        })),
      ),
      SwapBorrowRate$outboundSchema.and(
        z.object({ action: z.literal("SwapBorrowRate") }).transform((v) => ({
          action: v.action,
        })),
      ),
      Borrow$outboundSchema.and(
        z.object({ action: z.literal("Borrow") }).transform((v) => ({
          action: v.action,
        })),
      ),
      RedeemUnderlying$outboundSchema.and(
        z.object({ action: z.literal("RedeemUnderlying") }).transform((v) => ({
          action: v.action,
        })),
      ),
      Repay$outboundSchema.and(
        z.object({ action: z.literal("Repay") }).transform((v) => ({
          action: v.action,
        })),
      ),
      Supply$outboundSchema.and(
        z.object({ action: z.literal("Supply") }).transform((v) => ({
          action: v.action,
        })),
      ),
      UsageAsCollateral$outboundSchema.and(
        z.object({ action: z.literal("UsageAsCollateral") }).transform((v) => ({
          action: v.action,
        })),
      ),
    ]),
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AaveHistoricalTransactionsResponse$ {
  /** @deprecated use `AaveHistoricalTransactionsResponse$inboundSchema` instead. */
  export const inboundSchema = AaveHistoricalTransactionsResponse$inboundSchema;
  /** @deprecated use `AaveHistoricalTransactionsResponse$outboundSchema` instead. */
  export const outboundSchema =
    AaveHistoricalTransactionsResponse$outboundSchema;
  /** @deprecated use `AaveHistoricalTransactionsResponse$Outbound` instead. */
  export type Outbound = AaveHistoricalTransactionsResponse$Outbound;
}

export function aaveHistoricalTransactionsResponseToJSON(
  aaveHistoricalTransactionsResponse: AaveHistoricalTransactionsResponse,
): string {
  return JSON.stringify(
    AaveHistoricalTransactionsResponse$outboundSchema.parse(
      aaveHistoricalTransactionsResponse,
    ),
  );
}

export function aaveHistoricalTransactionsResponseFromJSON(
  jsonString: string,
): SafeParseResult<AaveHistoricalTransactionsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AaveHistoricalTransactionsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AaveHistoricalTransactionsResponse' from JSON`,
  );
}
