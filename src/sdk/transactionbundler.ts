/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { transactionBundlerTransactionBundlerAaveLoop } from "../funcs/transactionBundlerTransactionBundlerAaveLoop.js";
import { transactionBundlerTransactionBundlerAuthorization } from "../funcs/transactionBundlerTransactionBundlerAuthorization.js";
import { transactionBundlerTransactionBundlerExecute } from "../funcs/transactionBundlerTransactionBundlerExecute.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class TransactionBundler extends ClientSDK {
  /**
   * Enable Transaction Bundling
   *
   * @remarks
   * Get authorization for bundling transactions.
   *
   * Currently this is required for every transaction bundle to prevent replay attacks
   * and ensure transaction ordering when batching multiple actions into a single
   * transaction. The authorization includes a nonce and chain ID to guarantee
   * transaction uniqueness and proper network targeting.
   */
  async transactionBundlerAuthorization(
    request: components.MulticallAuthorizationRequest,
    options?: RequestOptions,
  ): Promise<components.MulticallAuthorizationResponse> {
    return unwrapAsync(transactionBundlerTransactionBundlerAuthorization(
      this,
      request,
      options,
    ));
  }

  /**
   * Construct Bundled Transaction
   *
   * @remarks
   * Bundle arbitrary transactions together into a single multicall transaction using
   * EIP-7702.
   *
   * This endpoint allows bundling multiple contract calls into a single atomic
   * transaction, reducing gas costs and ensuring all operations succeed or fail
   * together. The transaction must be authorized using the /authorization endpoint to
   * prevent replay attacks.
   */
  async transactionBundlerExecute(
    request: components.MulticallExecuteRequest,
    options?: RequestOptions,
  ): Promise<components.BundlerTransactionResponse> {
    return unwrapAsync(transactionBundlerTransactionBundlerExecute(
      this,
      request,
      options,
    ));
  }

  /**
   * AAVE Leverage Long/Short
   *
   * @remarks
   * Execute an Aave looping strategy that involves repeated supply and borrow
   * operations.
   *
   * This endpoint creates a multicall transaction that performs a series of operations:
   * 1. Approves and supplies initial token
   * 2. For each loop:
   *     - Borrows another token
   *     - Swaps borrowed token back to supply token
   *     - Supplies the swapped tokens
   *
   * The transaction must be authorized using the /authorization endpoint to prevent replay attacks.
   */
  async transactionBundlerAaveLoop(
    request: components.AaveLoopRequest,
    options?: RequestOptions,
  ): Promise<operations.ResponseV1TransactionBundlerAaveLoop> {
    return unwrapAsync(transactionBundlerTransactionBundlerAaveLoop(
      this,
      request,
      options,
    ));
  }
}
